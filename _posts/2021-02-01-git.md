---
title: "Git 교육 정리"
excerpt: "Basecamp 교육"

categories:
 - study
tags:
 - git
 - github
---


# Git 교육
[출처: Git/GitHub 교육 - 신승엽 책임님]

## 버전 관리 시스템
- 중앙집중식
    - 장점
        - 버전 관리 시스템의 장점들
    - 단점
        - 중앙 서버가 잘못되면 모든 데이터가 잘못됨
- 분산 버전 관리 시스템
    - 분산된 서버에 대해서 관리

## Git기초
- 델타가 아니라 스냅샷(Subversion이나 비슷한 VCS)
    - 각 파일의 변화를 시간순으로 관리
- Git
    - Git의 데이터는 파일의 스냅샷
    - 파일이 달라지지 않으면 이전 버전의 링크만 저장
    - 모든 파일 구조를 가지고 있음
    - 속도가 빠르다

- 거의 모든 명령을 로컬에서 실행
    - 모든 히스토리가 로컬 디스크에 있음

- Git의 무결성
    - 모든 데이터를 저장하기 전 체크섬(해시)을 구하고 체크섬으로 데이터를 관리
    - SHA-1 해시 사용
    - 40자 길이의 16진수 문자열
    - 파일을 이름으로 저장하지 않고 해당 파일의 해시로 저장

- 세 가지 상태
    - Committed
        - 데이터가 로컬 데이터베이스에 안전하게 저장 됨
    - Modified
        - 수정한 파일을 아직 로컬 데이터베이스에 커밋하지 않음
    - Staged
        - 수정한 파일을 곧 커밋할 것이라고 표시

- Git으로 하는 기본적인 일
    - 워킹 디렉토리에서 파일을 수정

## 기초 설정 (git-fork 사용)
- Git Repository 생성 시 Tip
    - 'Add Readme.md'하면 레포지토리에서 clone를 하기가 쉽다.

## Git 기초 사용법

### 파일 수정과 상태 변경
- 워킹 디렉토리의 파일은 Tracked와 Untracked로 나뉨
- Trcacked
    - 이미 스냡샷에 포함
    - Commited
    - Modified
    - Stated
- Untracked
    - 그 외
- Unstaged -> staged / staged에 있는 파일은 Commited 가능
- staged에 파일을 수정하면 staged와 unstaged 상태에 둘 다 공존
    -> unstaged에 있는 변경사항을 stage로 옮기면 기존 수정사항과 합쳐짐

#### Commit
- 파일 및 폴더의 추가/변경 사항들에 대해 기록을 하는 것

#### .gitignore
- 빌드 결과물 혹은 임시 파일 등은 굳이 버전관리를 할 필요가 없음
- Stage에 추가하지 않는 식으로 관리할 수도 있겠지만 git이 해당 파일들을 무시하도록 할 수 있음
- .gitignore라는 텍스트 파일을 만들어서 한줄씩 무시할 파일 이름의 패턴을 적어주면 됨
- .gitignore를 만들어주는 사이트 : https://www.gitignore.io
    - 운영체제, 언어 등을 고려해 자동으로 만들어 주는 사이트

- 이미 버전 관리된 파일을 무시하기
    - 이미 커밋되어 버전관리가 되는 파일은 이후에 .gitignore에 추가해도 무시되지 않음
    - 이 경우 해당 파일을 삭제한 후 커밋하고 해야함
        - 무시할 파일의 경우 저장소에 들어 있지 않아도 빌드 과정에서 다시 만들어지는 파일이므로 삭제해도 무방함  

### 브랜치
- 브랜치는 포인터
- 실제 개발 과정에서 겪을 만한 예제
    1. 작업 중인 웹사이트가 있다.
    2. 새로운 이슈를 처리할 새 브랜치를 하나 생성한다.
    3. 새로 만든 브랜치에서 작업을 진행한다.
- 중요한 문제가 생겨서 해결하는 hotfix를 만들어야 한다면
    1. 새로운 이슈를 처리하기 전의 운영 브랜치로 이동한다.
    2. hotfix 브랜치를 새로 생성한다.
    3. 수정한 hotfix 테스트를 마치고 운영 브랜치로 머지한다.
    4. 다시 작업하던 브랜치로 옮겨가서 하던 일을 진행한다.  
    
#### Git이 데이터를 저장하는 방법
- Git이 브랜치를 어떻게 다루는지 알려면 Git이 데이터를 어떻게 저장하는지 살펴봐야 함
- 커밋을 하면 Git은 커밋 개체를 생성
- Git의 브랜치는 커밋을 가리키는 포인터
- HEAD: 현재 워킹 디렉토리를 가리킴
- checkout: 워킹 디렉토리를 변경  

#### 머지
- merge를 할 때 합쳐지는 브랜치로 checkout 후 머지를 진행해야함
- 머지 커밋은 부모가 2개
- 같은 이름의 파일을 수정했을 때 머지 충돌이 발생할 수 있음

#### 브랜치 삭제
- 포인터만 삭제하기 때문에 history는 유지

#### Fast-forward
- 상황에 따라 머지했을 때 포인터만 이동하는 것
- Fast-forward로 머지할 브랜치만 작업 커밋이 있을때만 가능(머지될 브랜치에 작업 커밋이 있으면 Fast-forward 안됨)

#### 메인 브랜치
- 항상 존재하는 브랜치
- main(master)
    - 배포된 소스가 있음
- develop
    - 다음에 배포할 소스
    - 개발이 완료되면 main에 merge함

#### 서포팅 브랜치
- 필요할 때 생성했다가 삭제하는 브랜치
- feature 브랜치
    - 생성: develop로 부터
    - 머지: develop으로
    - prefix: feature/
    - feature 브랜치는 특정 기능 하나에 대하여 develop으로부터 생성하여 개발하며 개발이 완료되면 다시 develop 브랜치로 머지합니다.
    - fast-forward를 사용하지 않음
    
- release 브랜치
    - 생성: develop로 부터
    - 머지: develop과 main(master)로
    - 배포를 준비하는 브랜치
    - 마스터에 version tag를 붙임
    - QA 진행

- hotfix 브랜치
    - 생성: master로부터
    - 머지: devleop과 main(master)로
    - 긴급한 수정사항을 개발하는 브랜치

### 원격 저장소
- GitHub에 있는 원격 저장소를 origin이라는 이름을 GitHub에서 자동으로 붙여줌

#### 로컬 브랜치와 원격 브랜치
- 로컬 브랜치는 기본적으로 origin을 tracking하고 있음
- 로컬 브랜치인 main(master)와 origin/main(master)는 서로 별개의 브랜치임
- .git에 들어가면 로컬 저장소 파일 구조를 확인할 수 있음
- 브랜치의 git 내용을 확인하는 방법: git cat-file -p [commit hash값]

#### Fetch
- 원격 저장소에 있는 내용을 로컬 저장소에 내려받는 것
- 변경 사항을 받았을 뿐 로컬 브랜치에 반영되지 않음
- 머지를 하기 위해서는 수동으로 머지 해줘야함

#### Pull
- Fetch + Merge (변경사항을 받아와 Merge 해줌)

#### Push
- 변경사항을 원격 저장소에 반영하는 것

[실습은 생략]
